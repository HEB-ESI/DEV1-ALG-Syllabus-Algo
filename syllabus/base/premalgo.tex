%=============================
\chapter{Premiers algorithmes}
%=============================

	\marginicon{objectif}
	Dans le chapitre précédent,
	vous avez appris à analyser un problème
	et à clairement le spécifier.
	Il est temps d'écrire des solutions.
	Pour cela, nous allons devoir trouver
	comment passer des données au résultat
	et l'exprimer dans un langage compris de tous, 
	le \emph{Langage de Description d'Algorithmes} 
	(ou \emph{LDA}).
	
	%================================================
	\section{Un problème simple}
	%================================================
	
		%===================================
		\subsection{Trouver l'algorithme}
		%=================================

			Illustrons notre propos sur l'exemple 
			qui a servi de fil conducteur
			tout au long du chapitre précédent.
			Rappelons l'énoncé et l'analyse qui en a été faite.
			
			\begin{Emphase}
				\paragraph{Problème.}
				Calculer la surface d'un rectangle 
				à partir de sa longueur et sa largeur.
			
				\paragraph{Analyse.} 
				Nous sommes arrivés à la spécification suivante :
				\begin{center}
				\flowalgodd{longueur (réel)}{largeur (réel)}{surfaceRectangle}{réel}
				\end{center}
				
				\textbf{Exemples.} 
				\begin{multicols}{2}
					\begin{itemize}
					\item \lda{surfaceRectangle(3,2)} donne $6$ ;
					\item \lda{surfaceRectangle(3.5,1)} donne $3.5$.		
					\end{itemize}
				\end{multicols}
			\end{Emphase}
			
			\paragraph{Comment résoudre ce problème ?} 
			La toute première étape est de comprendre comment passer des données
			au résultat. Ici, on va se baser sur la formule de la surface :
			\[
				\textrm{surface} = \textrm{longueur} * \textrm{largeur}
			\]
			La surface s'obtient donc en multipliant la longueur par la largeur%
			\footnote{%
				Trouver la bonne formule n'est pas toujours facile.
				Dans votre vie professionnelle, 
				vous devrez parfois écrire un algorithme
				pour un domaine que vous connaissez peu,
				voire pas du tout.
				Il vous faudra alors chercher de l'aide,
				demander à des experts du domaine.
				Dans ce cours,
				nous essaierons de nous concentrer sur des problèmes
				qui ne vous sont pas complètement étrangers.
			}.
			
			En LDA, la solution s'écrit :
			
			\begin{LDA}
				\Algo{surfaceRectangle}{\Par{longueur, largeur}{réel}}{réel}
					\Return longueur * largeur
				\EndAlgo
			\end{LDA}
		
			La paire \lda{\algorithmicalgo-\algorithmicend\ \algorithmicalgo}
			permet de délimiter l'algorithme.
			La première ligne est appelée 
			\textbf{l'entête}\index{entête} de l'algorithme.
			On y retrouve :
			\begin{itemize}
				\item 
					le nom de l'algorithme,
				\item 
					une déclaration des données, 
					qu’on appellera ici les \textbf{paramètres}, 
				\item 
					le type du résultat.
			\end{itemize}
		
			Les paramètres recevront des valeurs concrètes
			(nous verrons comment)
			au \textbf{début} de l’exécution de l'algorithme. 
		
			L'instruction \lda{\algorithmicreturn}\index{retourner}
			permet d'indiquer la valeur du résultat, 
			ce que l'algorithme \emph{retourne}.
			Si on spécifie une formule, un calcul,
			c'est le résultat (on dit l'\emph{évaluation}) 
			de ce calcul qui est retourné et pas la formule.
		
			Pour indiquer le calcul à faire,
			écrivez-le, pour le moment,
			naturellement comme vous le feriez en mathématique.
			La seule différence notable est l'utilisation de \lda{*}
			pour indiquer une multiplication.
			Nous donnerons plus de détails plus loin.
	
		%===================================
		\subsection{Vérifier l'algorithme}
		\index{vérifier un algorithme}
		%=================================
		
			Lorsque vous avez terminé un exercice,
			vous le montrez à votre professeur pour qu'il
			vous dise s'il est correct ou pas.
			Fort bien !
			Mais vous pourriez trouver la réponse tout seul.
			Il vous suffit d'exécuter l'algorithme
			avec des exemples numériques et de vérifier que la réponse
			fournie est correcte.
			Votre professeur n'est indispensable que pour :
			\begin{itemize}
			\item
				vérifier qu'il fonctionne également
				dans certains cas particuliers
				auxquels il est difficile de penser quand on débute ;
			\item
				donner son avis sur la qualité de votre solution
				c-à-d essentiellement sur sa lisibilité.
				Nous y reviendrons.
			\end{itemize}
		
			Vous éprouvez souvent des difficultés à tester un algorithme
			car vous oubliez d'\textbf{éteindre votre cerveau}.
			Il faut agir comme une machine
			et exécuter \textbf{ce qui est écrit} 
			pas ce que vous pensez avoir écrit,
			ce qu'il est censé faire.
			Cela demande un peu de pratique.

			\begin{Emphase}
				\paragraph{Exemple.} 
				Vérifions notre solution 
				pour le calcul de la surface du rectangle
				en reprenant les exemples choisis.
				
				\begin{center}
				\begin{tabular}{|c|cccc|c|}
				\hline
				test \no & longueur & largeur & réponse attendue & réponse fournie & {} \\\hline
				\hline 
				1 & 3   & 2 & 6   & 6   & {\color{ForestGreen}$\checkmark$} \\\hline
				2 & 3.5 & 1 & 3.5 & 3.5 & {\color{ForestGreen}$\checkmark$} \\\hline
				\end{tabular}
				\end{center}				
			\end{Emphase}
			
			\bigskip
			\marginicon{attention}
			\textbf{Attention} : 
			Dans tous les exercices qui suivront,
			chaque fois qu'on vous demandera d'écrire un algorithme,
			on attendra de vous : de spécifier le problème,
			de fournir des exemples, d'écrire l'algorithme
			et de le vérifier sur vos exemples.
			Ce n'est que si tous ces éléments sont présents
			que votre solution pourra être considérée comme complète.

\clearpage
		%-------------------------------------------
		\subsection{Exercices}\label{prem-ex-simple}
		%-------------------------------------------

			Les exercices suivants ont déjà été analysés 
			dans un précédent chapitre
			et des exemples numériques ont été choisis.
			Il ne vous reste plus qu'à écrire l'algorithme
			et à le vérifier pour les exemples choisis.

			Vous pouvez vous baser sur la fiche \vref{fiche:calcul-simple} 
			qui résume la résolution 
			du calcul de la surface d'un rectangle,
			depuis l'analyse de l'énoncé jusqu'à l'algorithme
			et à sa vérification.
	
			\begin{Exercice}{Somme de 2 nombres}
				Calculer la somme de deux nombres donnés.
				\paragraph{Solution.}
				Rappelons ce que nous avons obtenus 
				lors de la phase d'analyse du problème.
				\begin{center}
					\flowalgodd{nombre1 (réel)}{nombre2 (réel)}{somme}{réel}
				\end{center}
				Sommer deux nombres est un problème trivial.
				L'algorithme s'écrit simplement :			
				\begin{LDA}
					\Algo{somme}{\Par{nombre1, nombre2}{réel}}{réel}
						\Return nombre1 + nombre2
					\EndAlgo
				\end{LDA}
				Cet exercice est plutôt simple 
				et il est facile de vérifier qu'il fournit
				bien les bonnes réponses pour les exemples choisis.				
				\begin{center}
					\begin{tabular}{|c|cccc|c|}
					\hline
					test \no & nombre1 & nombre2 & réponse attendue & réponse fournie & {} \\\hline
					\hline 
					1 & 3    & 2   & 5   & 5   & {\color{ForestGreen}$\checkmark$} \\\hline
					2 & -3   & 2   & -1  & -1  & {\color{ForestGreen}$\checkmark$} \\\hline
					1 & 3    & 2.5 & 5.5 & 5.5 & {\color{ForestGreen}$\checkmark$} \\\hline
					2 & -2.5 & 2.5 & 0   & 0   & {\color{ForestGreen}$\checkmark$} \\\hline
					\end{tabular}
				\end{center}				
			\end{Exercice}
		
			\begin{Exercice}{Moyenne de 2 nombres}
				Calculer la moyenne de deux nombres donnés.
			\end{Exercice}
			
			\begin{Exercice}{Surface d’un triangle}
				Calculer la surface d’un triangle 
				connaissant sa base et sa hauteur.
			\end{Exercice}
		
			\begin{Exercice}{Périmètre d’un cercle}
				Calculer le périmètre d’un cercle dont on donne le rayon. 
			\end{Exercice}
		
			\begin{Exercice}{Surface d’un cercle}
				Calculer la surface d’un cercle dont on donne le rayon. 
			\end{Exercice}
		
			\begin{Exercice}{TVA}
				Si on donne un prix hors TVA, il faut lui ajouter 21\% 
				pour obtenir le prix TTC. Écrire un algorithme qui permet 
				de passer du prix HTVA au prix TTC.
			\end{Exercice}
		
			\begin{Exercice}{Les intérêts}
				Calculer les intérêts reçus après 1 an 
				pour un montant placé en banque à du 2\% d’intérêt.
			\end{Exercice}
		
			\begin{Exercice}{Placement}
				Étant donné le montant d’un capital placé (en \texteuro) 
				et le taux d’intérêt annuel (en \%), calculer la
				nouvelle valeur de ce capital après un an.
			\end{Exercice}
		
			\begin{Exercice}{Conversion HMS en secondes}
				Étant donné un moment dans la journée donné
				par trois nombres, à savoir, heure, minute et seconde, calculer le
				nombre de secondes écoulées depuis minuit.
			\end{Exercice}
	
			\begin{Exercice}{Prix TTC}
				Étant donné le prix unitaire d’un produit
				(hors TVA), le taux de TVA (en \%) 
				et la quantité de produit vendue à un client, 
				calculer le prix total à payer par ce client.
			\end{Exercice}
			
	%================================================
	\section{Décomposer les calculs}
	%================================================
	
		Dans les exercices de la section précédente,
		vous avez écrit quelques longues formules%
		\footnote{%
			Et ce n'est encore rien comparé à ce qui nous attend ;)%
		}.
		Pour que cela reste lisible,
		il serait bon de pouvoir \emph{décomposer}
		le calcul en étapes.
		Pour ce faire, nous devons introduire deux nouvelles notions :
		les \emph{variables locales} et \emph{l'assignation}.
		
		%-----------------------------------------
		\subsection{Les variables}\index{variable}
		%-----------------------------------------
		
			\marginicon{definition}
			Une \textbf{variable locale} (ou simplement variable)
			est une zone mémoire à laquelle on a donné un nom
			et qui contiendra des valeurs d'un type donné.
			Elles vont servir à retenir des étapes intermédiaires
			de calculs.
			\begin{itemize}
			\item
				On parle de \textbf{variable}
				car son contenu \emph{peut} changer
				pendant le déroulement de l'algorithme.
			\item
				On l'appelle \textbf{locale}
				car elle n'est connue et utilisable qu'au sein
				de l'algorithme où elle est déclarée%
				\footnote{%
					Certains langages proposent également des variables
					\emph{globales} qui sont connues dans tout un programme.
					Nous ne les utiliserons pas dans ce cours ;
					voilà pourquoi on se contentera de dire "variable".%
				}.
			\end{itemize}		
			Pour être utilisable, 
			une variable doit être \emph{déclarée}%
			\footnote{%
				Certains langages permettent 
				d'utiliser des variables sans les déclarer.
				Ce ne sera pas le cas de Java.
			}
			au début de l'algorithme. 	
			La déclaration\index{déclaration} d’une variable 
			est l’instruction qui définit son nom et son type. 
			On pourrait écrire~:
	
			\begin{LDA}
				\Stmt longueur et largeur seront les noms de deux objets destinés à recevoir
				\Stmt les longueur et largeur du rectangle, c’est-à-dire des nombres à valeurs réelles.
			\end{LDA}
			
			Mais, bien entendu, cette formulation, trop proche du
			langage parlé, serait trop floue et trop longue. 
			Dès lors, nous abrégerons par~:
	
			\begin{LDA}
				\Decl{longueur, largeur}{réels}
			\end{LDA}
			
			Pour choisir le nom d'une variable,
			les règles sont les mêmes que pour les données d'un problème.
	
		%-----------------------------------------
		\subsection{L'assignation}\index{assignation}
		%--------------------------------------------
	
			\marginicon{definition}
			L'\textbf{assignation} 
			(on dit aussi \emph{affectation interne}\index{affectation interne})
			est une instruction qui donne une valeur 
			à une variable ou la modifie.
	
			Cette instruction est probablement la plus importante
			car c'est ce qui permet de retenir les résultats 
			de calculs intermédiaires.
			
			\begin{LDA}
			\Let nomVariable \Gets expression
			\end{LDA}
				
			Rappelons qu’une \textbf{expression} 
			est un calcul, une combinaison de variables et
			d’opérateurs. Une expression a une valeur.
					
			\paragraph{Exemples d'assignations correctes.}
			%------------------------------------------------
				
				\begin{LDA}
				\Let somme \Gets nombre1 + nombre2
				\Let denRes \Gets den1 * den2
				\Let cpt \Gets cpt + 1
				%\Let delta \Gets b**2 – 4*a*c
				\Let test \Gets a < b \RComment pour une variable logique
				\Let maChaine \Gets "bonjour"
				\Let maChaine \Gets bonjour	\RComment comprenez-vous la différence ?
				%\Let uneChaine \Gets concat(maChaine, "jour")
				\end{LDA}
				
			\paragraph{Exemples d'assignations incorrectes}
			%--------------------------------------------------				
				\begin{LDA}
				\Let somme + 1 \Gets 3
				\RComment somme + 1 n’est pas une variable
				\Let somme \Gets 3n
				\RComment 3n n’est ni un nom de variable correct ni une expression correcte
				\end{LDA}
				
			\paragraph{Remarques}
			%------------------------
			
				\begin{itemize}
				\item 
					\textbf{Une assignation n'est pas une égalité, une définition}.
					\\Ainsi, l'assignation \lda{cpt \Gets cpt + 1}
					ne veut pas dire que $\textrm{cpt} = \textrm{cpt} + 1$,
					ce qui est mathématiquement faux 
					mais que la \emph{nouvelle} valeur de \lda{cpt}
					doit être calculée en ajoutant 1 à sa valeur actuelle.
					Ce calcul doit être effectué au moment 
					où on exécute cette instruction. 
				\item 
					Seules les variables déclarées peuvent être affectées.
				\item 
					Toutes les variables apparaissant dans une expression
					doivent avoir été affectées préalablement. 
					Le contraire provoquerait une erreur,
					un arrêt de l’algorithme.
				\item 
					La valeur affectée à une variable 
					doit être compatible avec son type.
					Pas question de mettre une chaine dans une variable
					booléenne.
				\end{itemize}
				
		\subsection{Tracer un algorithme}
		%--------------------------------
		
			Pour vérifier qu'un algorithme est correct,
			on sera souvent amené à le \textbf{tracer}.
			Cela consiste à suivre l'évolution des variables
			et à vérifier qu'elles contiennent bien à tout moment
			la valeur attendue.
			
			\paragraph{Exemple.} Traçons des bouts d'algorithmes.
			
			\begin{minipage}{4cm}
			\begin{LDA}[1]
				\Decl{a, b, c}{entiers}
				\Let a \Gets 12
				\Let b \Gets 5
				\Let c \Gets a - b
				\Let a \Gets a + c
				\Let b \Gets a
			\end{LDA}
			\end{minipage}
			\quad%
			\begin{minipage}{7cm}
			\begin{tabular}{|>{\centering\arraybackslash}m{1cm}|*{3}{>{\centering\arraybackslash}m{2cm}}|}
				\hline
				\verb_#_ & {a} & {b} & {c}\\
				\hline
				1 & {indéfini}             & {indéfini}             & {indéfini}             \\
				2 & {12}                   & {\color{gray}$\mid$}   & {\color{gray}$\mid$}   \\
				3 & {\color{gray}$\mid$}   & {5}                    & {\color{gray}$\mid$}   \\
				4 & {\color{gray}$\mid$}   & {\color{gray}$\mid$}   & {7}                    \\
				5 & {19}                   & {\color{gray}$\mid$}   & {\color{gray}$\mid$}   \\
				6 & {\color{gray}$\mid$}   & {19}                   & {\color{gray}$\mid$}   \\
				\hline
			\end{tabular}
			\end{minipage}

			\bigskip
			\begin{minipage}{4cm}
			\begin{LDA}[1]
				\Decl{a, b, c}{entiers}
				\Let a \Gets 12
				\Let c \Gets a - b
				\Let d \Gets c - 2
			\end{LDA}
			\end{minipage}
			\quad%
			\begin{minipage}{7cm}
			\begin{tabular}{|>{\centering\arraybackslash}m{1cm}|*{3}{>{\centering\arraybackslash}m{2cm}}|}
				\hline
				\verb_#_ & {a} & {b} & {c}\\
				\hline
				1 & {indéfini}             & {indéfini}             & {indéfini}             \\
				2 & {12}                   & {\color{gray}$\mid$}   & {\color{gray}$\mid$}   \\
				3 & {\color{gray}$\mid$}   & {\color{gray}$\mid$}   & ???                    \\
				4 & {\color{gray}$\mid$}   & {\color{gray}$\mid$}   & ???                    \\
				\hline
			\end{tabular}
			\end{minipage}
			
			\lda{c} ne peut pas être calculé car b n’a pas été initialisé;
			quant à \lda{d}, il n’est même pas déclaré~!

			\begin{Exercice}{Tracer des bouts de code}
				Suivez l'évolution des variables pour les bouts
				d'algorithmes donnés.
	
				\begin{minipage}{4cm}
				\begin{LDA}[1]
					\Decl{a, b, c}{entiers}
					\Let a \Gets 42
					\Let b \Gets 24
					\Let c \Gets a + b
					\Let c \Gets c - 1
					\Let a \Gets 2 * b
					\Let c \Gets c + 1
				\end{LDA}
				\end{minipage}
				\quad%
				\begin{minipage}{7cm}
					\begin{tabular}{|>{\centering\arraybackslash}m{1cm}|*{3}{>{\centering\arraybackslash}m{2cm}}|}
					\hline
					\verb_#_ & {a} & {b} & {c}\\
					\hline
					1 & {} & {} & {} \\
					2 & {} & {} & {} \\
					3 & {} & {} & {} \\
					4 & {} & {} & {} \\
					5 & {} & {} & {} \\
					6 & {} & {} & {} \\
					7 & {} & {} & {} \\
					\hline
					\end{tabular}
				\end{minipage}
				
				\bigskip
				\begin{minipage}{4cm}
				\begin{LDA}[1]
					\Decl{a, b, c}{entiers}
					\Let a \Gets 2
					\Let b \Gets a$^3$
					\Let c \Gets b - a$^2$
					\Let a \Gets $\sqrt{c}$
					\Let a \Gets a / a
				\end{LDA}
				\end{minipage}
				\quad%
				\begin{minipage}{7cm}
					\begin{tabular}{|>{\centering\arraybackslash}m{1cm}|*{3}{>{\centering\arraybackslash}m{2cm}}|}
					\hline
					\verb_#_ & {a} & {b} & {c}\\
					\hline
					1 & {} & {} & {} \\
					2 & {} & {} & {} \\
					3 & {} & {} & {} \\
					4 & {} & {} & {} \\
					5 & {} & {} & {} \\
					6 & {} & {} & {} \\
					\hline
					\end{tabular}
				\end{minipage}	
			\end{Exercice}
		
			\begin{Exercice}{Calcul de vitesse}
				Soit le problème suivant :
				\og
					Calculer la vitesse (en km/h) d'un véhicule 
					dont on donne la durée du parcours (en secondes) 
					et la distance parcourue (en mètres).
				\fg.
				
				Voici une solution : 
				\begin{LDA}[1]
				\Algo{vitesseKMH}{\Par{distanceM, duréeS}{réel}}{réel}
					\Decl{distanceKM, duréeH}{réel}
					\Let distanceKM \Gets 1000 * distanceM
					\Let duréeH \Gets 3600 * duréeS
					\Return $\frac{\textrm{distanceKM}}{\textrm{duréeH}}$
				\EndAlgo
				\end{LDA}

				L'algorithme, s'il est correct, devrait donner
				une vitesse de 1 km/h pour une distance de 1000 mètres
				et une durée de 3600 secondes.
				Testez cet algorithme avec cet exemple.

				\begin{center}
				\begin{tabular}{|>{\centering\arraybackslash}m{1cm}|*{5}{>{\centering\arraybackslash}m{2cm}}|}
					\hline
						\verb_#_  &  &  & & &  \\			
					\hline
						1 & & & & & \\
						2 & & & & & \\
						3 & & & & & \\
						4 & & & & & \\
						5 & & & & & \\
					\hline
				\end{tabular}
				\end{center}
				
				Si vous trouvez qu'il n'est pas correct,
				voyez ce qu'il faudrait changer pour le corriger.
			\end{Exercice}
		
		%---------------------------------------------
		\subsection{Exercices de décomposition}
		%---------------------------------------------
					
			Savoir, face à un cas concret, s'il est préférable 
			de décomposer le calcul ou pas, n'est pas toujours évident.	
			La section \vref{lisibilite}
			sur la lisibilité vous apportera des arguments
			qui permettront de trancher.
	
			Les exercices qui suivent sont suffisamment complexes
			que pour mériter une décomposition du calcul.
			Ils ont déjà été analysés dans un précédent chapitre.
			On vous demande à présent d'en rédiger une solution
			et de la tracer pour vérifier que le résultat est correct.
			Vous pouvez vous baser sur la fiche \vref{fiche:calcul-complexe}
			qui présente un exemple complet.

				
			\begin{Exercice}{Durée de trajet}
				\label{algo:durée}
				Étant donné la vitesse moyenne en \textbf{m/s}
				d’un véhicule et la distance parcourue en \textbf{km} par ce véhicule,
				calculer la durée en secondes du trajet de ce véhicule.
				
				\paragraph{Solution.}
				L'analyse du problème aboutit à :
				\begin{center}
					\flowalgodd{vitesseMS (réel)}{distanceKM (réel)}{duréeTrajet}{réel}
				\end{center}
				La formule qui lie les trois éléments est :
				\[
					\mathrm{vitesse} = \frac{\mathrm{distance}}{\mathrm{temps}}
					\qquad \mathrm{\ qu'on\ peut\ aussi\ exprimer}\qquad
					\mathrm{temps} = \frac{\mathrm{distance}}{\mathrm{vitesse}}					
				\]
				pour autant que les unités soient compatibles.
				Dans notre cas, il faut d'abord convertir
				la distance en mètres, selon la formule :
				\[
					\mathrm{vitesseM} = 1000 * \mathrm{vitesseKM}					
				\]
				Quelques exemple numériques :
				\begin{multicols}{2}
					\begin{itemize}
					\item \lda{duréeeTrajet(1, 1) donne $1000$}
					\item \lda{duréeeTrajet(0.5, 0.2) donne $400$}
					\end{itemize}
				\end{multicols}
				L'algorithme s'écrit :
				\begin{LDA}[1]
					\Algo{duréeTrajet}{\Par{vitesseMS, distanceKM}{réel}}{réel}
						\Decl{distanceM}{réel}
						\Let distanceM \Gets 1000 * distanceKM
						\Return distanceM / vitesseMS
					\EndAlgo
				\end{LDA}
				
				Vérifions l'algorithme pour \lda{duréeeTrajet(1, 1)}
				\begin{center}
				\begin{tabular}{|>{\centering\arraybackslash}m{1cm}|*{4}{>{\centering\arraybackslash}m{2cm}}|}
					\hline
						\verb_#_  & vitesseMS & distanceKM & distanceM & résultat \\			
					\hline
						1 & 1                    & 1                    & {}                   & {} \\
						2 & {\color{gray}$\mid$} & {\color{gray}$\mid$} & indéfini             & {} \\
						3 & {\color{gray}$\mid$} & {\color{gray}$\mid$} & 1000                 & {} \\
						4 & {\color{gray}$\mid$} & {\color{gray}$\mid$} & {\color{gray}$\mid$} & 1000 \\
					\hline
				\end{tabular}
				\end{center}
	
				et pour \lda{duréeeTrajet(0.5, 0.2)}
				\begin{center}
				\begin{tabular}{|>{\centering\arraybackslash}m{1cm}|*{4}{>{\centering\arraybackslash}m{2cm}}|}
					\hline
						\verb_#_  & vitesseMS & distanceKM & distanceM & résultat \\			
					\hline
					1 & 0.5                  & 0.2                  & {}                   & {} \\
					2 & {\color{gray}$\mid$} & {\color{gray}$\mid$} & indéfini             & {} \\
					3 & {\color{gray}$\mid$} & {\color{gray}$\mid$} & 200                  & {} \\
					4 & {\color{gray}$\mid$} & {\color{gray}$\mid$} & {\color{gray}$\mid$} & 400 \\
					\hline
				\end{tabular}
				\end{center}								
			\end{Exercice}

			\begin{Exercice}{Allure et vitesse}
				L'allure d'un coureur est le temps qu'il met pour parcourir 1 km
				(par exemple, $4'37''$).
				On voudrait calculer sa vitesse (en km/h) à partir de son allure.
				Par exemple, la vitesse d'un coureur ayant une allure de
				$4'37''$ est de $14$ km/h. 
			\end{Exercice}
		
			\begin{Exercice}{Cote moyenne}
				Étant donné les résultats (cote entière sur
				20) de trois examens passés par un étudiant (exprimés par six nombres,
				à savoir, la cote et la pondération de chaque examen), calculer 
				la moyenne globale exprimée en pourcentage.
			\end{Exercice}
	
	%=============================================
	\section{Quelques difficultés liées au calcul}
	%=============================================
	
		Vous êtes habitués à effectuer des calculs.
		L'expérience nous montre toutefois que certains calculs
		vous posent des difficultés.
		Soit parce que ce sont des opérations que vous utilisez peu,
		soit parce que vous n'avez pas l'habitude de les voir comme des
		calculs.
		Citons : 
		\begin{itemize}
		\item
			assigner des valeurs booléennes 
			en fonction de comparaisons ;
		\item
			manipuler les opérateurs logiques ;
		\item
			utiliser la division entière et le reste.
		\end{itemize}
		
		Examinons ces situations une à une
		en fournissant des exemples et des exercices
		pour que cela devienne naturel pour vous.
		
		%------------------------------------------------------------------------
		\subsection{Les comparaisons et les assignations de variables booléennes}
		%------------------------------------------------------------------------
		\index{comparaisons}
		
			Si je vous dis que $3+1$ est un calcul
			dont le résultat est $4$, un entier
			vous n'aurez aucun mal à me croire ; 
			cela vous parait évident.
			Ce qui l'est peut-être moins c'est que $1<3$ est aussi
			un calcul dont le résultat est un \emph{booléen},
			vrai en l’occurrence. 
			Ce résultat peut être assigné à une variable booléenne.			

			\paragraph{Exemples.}
			Voici quelques assignations correctes 
			(les variables à gauche du \Gets sont des variables booléennes) :
			\begin{itemize}
				\item \lda{positif \Gets nb>0 \RComment positif est mis à vrai si le nb est positif} 
				\item \lda{adulte \Gets âge$\ge$21 \RComment adulte est vrai si l'âge est 21 ou plus}
				\item \lda{réussi \Gets cote$\ge$10 \RComment réussi est mis à vrai si la cote est supérieure ou égale à 10}
				\item \lda{parfait \Gets nbFautes=0 \RComment c'est parfait si le nombre de fautes est 0}
			\end{itemize}
		
			\begin{Exercice}{Écrire des expressions booléennes}
				Pour chacune des phrases suivantes,
				écrivez l'assignation qui lui correspond.
				\begin{itemize}
				\item 
					La variable booléenne \lda{négatif}
					doit indiquer si le nombre \lda{montant} est négatif.
				\item
					Un groupe est complet s'il contient exactement 20 personnes.
				\item
					Un algorithme est considéré comme long si le nombre de lignes
					dépasse 20.
				\item 
					Un étudiant a une \emph{grande distinction} si sa cote est
					de 18/20 ou plus.
				\end{itemize}
			\end{Exercice}

		%------------------------------------------------------------------------
		\subsection{Les opérations logiques}
		%------------------------------------------------------------------------
		\index{opérateurs logiques}\index{NON}\index{ET}\index{OU}
	
			Les opérateurs logiques agissent sur des expressions booléennes 
			(variables ou expressions à valeurs booléennes) 
			pour donner un résultat du même type.
	
			\begin{center}
			\begin{tabular}{m{1cm}|m{3cm}|m{8cm}}
			\raggedleft \lda{NON} & négation & vrai devient faux et inversement\\
			\raggedleft \lda{ET} & conjonction logique & vrai si les 2 conditions sont vraies\\
			\raggedleft \lda{OU} & disjonction logique & vrai si au moins une des 2 conditions est vraie\\
			\end{tabular}
			\end{center}
			
			Ce qu'on peut résumer par les tableaux suivants :
			
			\begin{center}
			\begin{tabular}{|cccc|}
				\hline
				a & b & a ET b & a OU b \\
				\hline
				vrai & vrai & vrai & vrai \\\hline
				vrai & faux & faux & vrai \\\hline
				faux & vrai & faux & vrai \\\hline
				faux & faux & faux & faux \\\hline				
			\end{tabular}
			\qquad
			\begin{tabular}{|cc|}
				\hline
				a & NON a \\
				\hline
				vrai & faux \\\hline
				faux & vrai \\\hline
			\end{tabular}
			\end{center}

\clearpage			
			On peut les utiliser 
			pour donner une valeur à une variable booléenne.
			Par exemple :
			
			\begin{small}
			\begin{multicols}{2}
				\begin{itemize}
					\item \lda{tarifPlein \Gets 18$\le$âge ET âge$<$60}
					\item \lda{distinction \Gets 16$\le$cote ET cote<18}
					\item \lda{nbA3chiffres \Gets 100$\le$nb ET nb$\le$999}
					\item \lda{tarifRéduit \Gets NON tarifPlein}
					\item \lda{tarifRéduit \Gets NON (18$\le$âge ET âge$<$60)}
					\item \lda{tarifRéduit \Gets âge$<$18 OU 60$\le$âge}
				\end{itemize}
			\end{multicols}
			\end{small}
	
			Écrire des calculs utilisant ces opérateurs n'est pas facile
			car le français nous induit souvent en erreur
			en nous poussant à utiliser un ET pour un OU et inversement
			ou bien à utiliser des raccourcis d'écriture ambigus%
			\footnote{%
				Vous noterez que le nombre de "et" et de "ou"
				dans cette phrase ne facilite pas sa compréhension ;)%
			}. 
			\\Par exemple, ne pas écrire : 
			\lda{tarifRéduit \Gets âge$<$18 OU $\ge$60}
	
			\paragraph{Loi de De Morgan.}
			Lorsqu'on a une expression complexe faisant intervenir
			des négations, on peut utiliser la \emph{Loi de De Morgan}
			pour la simplifier.
			Cette loi stipule que :
			\[
				\mathrm{NON}\ (a\ \mathrm{ET}\ b) \Leftrightarrow \mathrm{NON}\ a\ \mathrm{OU}\ \mathrm{NON}\ b
			\]
			\[
				\mathrm{NON}\ (a\ \mathrm{OU}\ b) \Leftrightarrow \mathrm{NON}\ a\ \mathrm{ET}\ \mathrm{NON}\ b
			\]
			
			Par exemple : \lda{tarifRéduit \Gets NON (18$\le$âge ET âge$<$60)}
			\\peut s'écrire aussi : \lda{tarifRéduit \Gets (NON 18$\le$âge) OU (NON âge$<$60)}
			\\ce qui se simplifie en : \lda{tarifRéduit \Gets âge$<$18 OU 60$\le$âge}

			\paragraph{Priorités et parenthèses.}
			Lorsqu'on écrit une expression mêlant les opérateurs logiques,
			on considère que NON est prioritaire sur ET qui l'est sur OU.
			
			Ainsi l'expression : \lda{NON a OU b ET c}
			doit se comprendre : \lda{(NON a) OU (b ET c)}.
			Vous pouvez toujours ajouter des parenthèses non nécessaires
			pour vous assurer d'être bien compris.
			 
			\begin{Exercice}{Simplifier des expressions booléennes}
				Voici quelques assignations correctes du point de vue de la
				syntaxe mais contenant des lourdeurs d’écriture.
				Trouvez des expressions plus simples
				qui auront un effet équivalent.
				\begin{itemize}
					\item \lda{ok \Gets adulte = vrai}
					\item \lda{ok \Gets adulte = faux}
					\item \lda{ok \Gets etudiant = vrai ET jeune = faux}
					\item \lda{ok \Gets NON (adulte = vrai) ET NON (adulte = faux)}
					\item \lda{nbA3chiffres \Gets NON (nb$<$100 OU nb$\ge$1000)}
				\end{itemize}		
			\end{Exercice}
		
			\begin{Exercice}{Expressions logiques}
				Pour chacune des phrases suivantes,
				écrivez l'assignation qui lui correspond.
				\begin{itemize}
				\item J’irai au cinéma si le film me plait et que j’ai 20\texteuro{} en poche.
				\item Je n’irai pas au cinéma si je n’ai pas 20\texteuro{} en poche.
				\item Je brosserai le premier cours de la journée s’il commence à 8h et aussi si je n’ai pas dormi mes 8h.
				\item Pour réussir GEN1, il faut au moins 10 dans chacune des AA qui le composent (math, anglais, compta).	
				\end{itemize}
			\end{Exercice}
			
		%-------------------------------------------
		\subsection{La division entière et le reste}
		%-------------------------------------------
		\index{DIV}\index{MOD}
		\index{division entière}
		\index{modulo}
		
			\marginicon{definition}
			La \textbf{division entière} consiste à effectuer une division
			en ne gardant que la partie entière du résultat.
			Dans ce cours, nous la noterons \lda{DIV}.
			Dit autrement, \lda{a DIV b}
			indique combien de fois on peut \emph{mettre} b dans a.
			
			\begin{minipage}{2cm}
			\textbf{Exemples} :	
			\\
			\end{minipage}
			\begin{minipage}{9cm}
			\begin{multicols}{2}
			\begin{itemize}
				\item 7 DIV 2 vaut 3
				\item 8 DIV 2 vaut 4
				\item 6 DIV 6 vaut 1
				\item 6 DIV 7 vaut 0
			\end{itemize}
			\end{multicols}
			\end{minipage}
			
			\marginicon{definition}
			Le \textbf{reste} de la division entière de a par b
			est ce qui n'a pas été repris dans la division.
			On va le noter \lda{a MOD b}
			et on dira \emph{a modulo b}.
	
			Un exemple vous aidera à comprendre.	
			Imaginons qu'une classe comprend 14 étudiants
			qu'il faut réunir par 3
			dans le cadre d'un travail de groupe.
			On peut former 4 groupes 
			mais il restera 2 étudiants ne pouvant former un groupe complet.
			C'est le reste de la division de 14 par 3.
			
			\begin{minipage}{2cm}
			\textbf{Exemples} :	
			\\
			\end{minipage}
			\begin{minipage}{9cm}
			\begin{multicols}{2}
			\begin{itemize}
				\item 7 MOD 2 vaut 1
				\item 8 MOD 2 vaut 0
				\item 6 MOD 6 vaut 0
				\item 6 MOD 7 vaut 6
			\end{itemize}
			\end{multicols}
			\end{minipage}
		
			Pour indiquer le lien entre la division et le reste,
			on écrira : $9/2 = 4\ \textrm{reste}\ 1$.

			\begin{Exercice}{Calculs}
				Voici quelques petits calculs.
				On vous demande de remplir les trous.
				
				\begin{multicols}{2}
					\begin{itemize}
					\item $11/3 = \_\_\ \textrm{reste}\ \_\_$
					\item $3/11 = \_\_\ \textrm{reste}\ \_\_$
					\item $11/\_\_ = 2\ \textrm{reste}\ 3$
					\item $\_\_/3 = 3\ \textrm{reste}\ 2$
					\end{itemize}
				\end{multicols}
			\end{Exercice}

			\begin{Exercice}{Les prix ronds}
				Voici un algorithme qui reçoit une somme d'argent exprimée en centimes
				et qui calcule le nombre (entier) de centimes qu'il
				faudrait ajouter à la somme pour tomber sur un prix rond en euros.
				Testez-le avec des valeurs numériques. Est-il correct ?
				
				\begin{LDA}
				\Algo{versPrixRond}{\Par{prixCentimes}{entier}}{entier}
					\Return 100 - (prixCentimes MOD 100)
				\EndAlgo
				\end{LDA}
				
				\begin{center}
				\begin{tabular}{|c|c|c|c|c|}
				\hline
				test \no & prixCentimes & réponse correcte & valeur retournée & Correct ? \\\hline
				\hline 
				1 & 130 & 70 &  & \\\hline
				2 & 40  & 60 &  & \\\hline
				3 & 99  & 1  &  & \\\hline
				4 & 100 & 0  &  & \\\hline
				\end{tabular}
				\end{center}
				
			\end{Exercice}
			
			
			\subsubsection{Tester la divisibilité}
			%-------------------------------------
			
				Les deux opérateurs \lda{MOD} et \lda{DIV}
				sont-ils vraiment utiles ?
				Oui ! Ils vont servir pour tester si un nombre
				est un multiple d'un autre et pour extraire
				des chiffres d'un nombre.
				Commençons par la divisibilité.

				Imaginons qu'on veuille tester qu'un nombre est pair.
				Qu'est-ce qu'un nombre pair ? Un nombre qui est multiple de 2.
				C'est-à-dire dont le reste de la division par 2 est nul.
				
				\[
				\textrm{nb pair} 
					\quad\equiv\quad \textrm{nb divisible par 2} 
					\quad\equiv\quad \textrm{nb MOD 2 = 0} 
				\]
				
				On peut donc écrire : \lda{pair \Gets nb MOD 2 = 0}.
	
			\subsubsection{Extraire les chiffres d'un nombre}
			%------------------------------------------------
			
				Faisons une petite expérience numérique.
				\begin{center}
				\begin{tabular}{|l|r|}\hline
					calcul & résultat \\\hline
					\hline
					65536 MOD 10 & 6 \\  
					65536 MOD 100 & 36 \\  
					65536 MOD 1000 & 536 \\  
					65536 MOD 10000 & 5536 \\ 
					\hline 
				\end{tabular}
				\qquad
				\begin{tabular}{|l|l|}\hline
					calcul & résultat \\\hline
					\hline
					65536 DIV 10 & 6553 \\  
					65536 DIV 100 & 655 \\  
					65536 DIV 1000 & 65 \\  
					65536 DIV 10000 & 6 \\ 
					\hline 
				\end{tabular}
				\end{center}
			
				On voit que les DIV et MOD avec des puissances de 10
				permettent de garder les chiffres de droite (MOD)
				ou d'enlever les chiffres de droites (DIV).
				Combinés, ils permettent d'extraire n'importe quel
				chiffre d'un nombre.
				
				\textbf{Exemple} : 65536 DIV 100 MOD 10 = 5.
									
		%---------------------
		\subsection{Exercices sur les difficultés de calcul}
		%---------------------
		\label{prem-ex-cplx}
		
			Les exercices qui suivent n'ont pas tous étés déjà analysés
			et ils demandent des calculs faisant intervenir
			des divisions entières, des restes et/ou des expressions booléennes.
			Comme d'habitude, écrivez la spécification
			si ça n'a pas encore été fait,
			donnez des exemples, rédigez un algorithme
			et vérifiez-le.
		
			\begin{Exercice}{Nombre multiple de 5}
				\label{algo:mult5}
				Calculer si un nombre entier positif donné est un multiple de 5.
				\paragraph{Solution.}
				Dans ce problème,
				il y a une donnée, le nombre à tester.
				La réponse est un booléen
				qui est à vrai si le nombre donné est un multiple de 5.
				\begin{center}
				\flowalgod{nombre (entier)}{multiple5}{booléen}
				\end{center}
				\textbf{Exemples.}
				\begin{multicols}{4}
					\begin{itemize}
					\item \lda{multiple5(4)} donne faux
					\item \lda{multiple5(15)} donne vrai
					\item \lda{multiple5(0)} donne vrai
					\item \lda{multiple5(-10)} donne vrai
					\end{itemize}
				\end{multicols}
				La technique pour vérifier si un nombre est
				un multiple de 5 est de vérifier que le reste
				de la division par 5 donne 0.
				Ce qui donne :
				\begin{LDA}[1]
					\Algo{multiple5}{\Par{nombre}{entier}}{booléen}
						\Return nombre MOD 5 = 0
					\EndAlgo
				\end{LDA}
				Vérifions sur nos exemples :
				\begin{center}
				\begin{tabular}{|c|c|c|c|c|}
				\hline
				test \no & nombre & réponse correcte & valeur retournée & Correct ? \\\hline
				\hline 
				1 & 4   & faux & faux & {\color{ForestGreen}$\checkmark$} \\\hline
				2 & 15  & vrai & vrai & {\color{ForestGreen}$\checkmark$} \\\hline
				3 & 0   & vrai & vrai & {\color{ForestGreen}$\checkmark$} \\\hline
				4 & -10 & vrai & vrai & {\color{ForestGreen}$\checkmark$} \\\hline
				\end{tabular}
				\end{center}
			\end{Exercice}

\clearpage	
			\begin{Exercice}{Nombre entier positif se terminant par un 0}
				Calculer si un nombre donné se termine par un 0.
			\end{Exercice}
	
			\begin{Exercice}{Les centaines}
				Calculer la partie \emph{centaine}
				d'un nombre entier positif quelconque.
			\end{Exercice}
	
			\begin{Exercice}{Somme des chiffres}
				Calculer la somme des chiffres
				d’un nombre entier positif inférieur à 1000.
			\end{Exercice}
		
			\begin{Exercice}{Conversion secondes en heures}
				Étant donné un temps écoulé depuis minuit.
				Si on devait exprimer ce temps sous la forme
				habituelle (heure, minute et seconde),
				que vaudrait la partie "heure".
		
				Ex~:~10000 secondes donnera 2 heures.
			\end{Exercice}
		
			\begin{Exercice}{Conversion secondes en minutes}
				Étant donné un temps écoulé depuis minuit.
				Si on devait exprimer ce temps sous la forme
				habituelle (heure, minute et seconde),
				que vaudrait la partie "minute".
		
				Ex~:~10000 secondes donnera 46 minutes.
			\end{Exercice}
		
			\begin{Exercice}{Conversion secondes en secondes}
				Étant donné un temps écoulé depuis minuit.
				Si on devait exprimer ce temps sous la forme
				habituelle (heure, minute et seconde),
				que vaudrait la partie "seconde".
		
				Ex~:~10000 secondes donnera 40 secondes.
			\end{Exercice}	
		
			\begin{Exercice}{Année bissextile}
				Écrire un algorithme qui vérifie si une année est bissextile. 
				Pour rappel, les années bissextiles sont les années multiples de 4. 
				Font exception, les multiples de 100 
				(sauf les multiples de 400 qui sont bien bissextiles). 
				Ainsi $2012$ et $2400$ sont bissextiles mais pas $2010$ ni $2100$.
			\end{Exercice}
			 		 
	%===================================
	\section{Des algorithmes de qualité}
	%===================================
	
		Dans la section précédente,
		nous avons vu qu'il est possible de décomposer un calcul en étapes.
		Mais quand faut-il le faire ?	
		Ou, pour poser la question autrement :
		
			\begin{quote}
				\textbf{Puisqu'il existe plusieurs algorithmes 
				qui résolvent un problème, lequel préférer ?}
			\end{quote}
		
		Répondre à cette question, 
		c'est se demander ce qui fait la qualité d'un algorithme
		ou d'un programme informatique.
		Quels sont les critères qui permettent de juger ?
		
		C'est un vaste sujet mais nous voudrions aborder les principaux.
		
		%------------------------------------------
		\subsection{L'efficacité}\index{efficacité}
		%------------------------------------------
			
			L'\textbf{efficacité}
			désigne le fait que l'algorithme (le programme) résout%
			\footnote{%
				À ne pas confondre avec \emph{l'efficience}
				qui indique qu'il est économe en ressources.
			}
			bien le problème donné.
			C'est un minimum !
		
		%-------------------------------------------
		\subsection{La lisibilité}\index{lisibilité}
		%-------------------------------------------
		
			La \textbf{lisibilité}
			indique si une personne qui lit l'algorithme
			(ou le programme)
			peut facilement percevoir comment il fonctionne.
			C'est crucial car un algorithme (un programme) 
			est \textbf{souvent lu} par de nombreuses personnes :
			\begin{itemize}
			\item
				celles qui doivent se convaincre de sa validité
				avant de passer à la programmation ;
			\item
				celles qui doivent trouver les causes
				d'une erreur lorsque celle-ci a été rencontrée%
				\footnote{%
					On parle du processus de \emph{déverminage}
					(ou \emph{debugging} en Anglais).%
				} ;
			\item
				celles qui doivent faire évoluer l'algorithme
				ou le programme suite à une modification
				du problème ;
			\item
				et, accessoirement, celles qui doivent le coter ;)
			\end{itemize}
			
			C'est un critère \textbf{très important}
			qu'il ne faut surtout pas sous-évaluer.
			Vous en ferez d'ailleurs l'amère expérience :
			si vous négligez la lisibilité d'un algorithme,
			vous-même ne le comprendrez plus quand vous le relirez
			quelques temps plus tard !
			
			Comparer la lisibilité de deux algorithmes
			n'est pas une tâche évidente car c'est une notion subjective.
			Il faut se demander quelle version va être le plus facilement
			comprise par la majorité des lecteurs.		
			La section \vref{lisibilite}
			explique ce qui peut être fait pour rendre ses algorithmes
			plus lisibles.
				
		%---------------------------------------	
		\subsection{La rapidité}\index{rapidité}
	    %---------------------------------------
	    
			La \textbf{rapidité}
			indique si l'algorithme (le programme)
			permet d'arriver plus ou moins vite au résultat.
			
			C'est un critère qui est souvent sur-évalué, 
			essentiellement pour deux raisons.
			\begin{itemize}
				\item 
					Il est trompeur. 
					On peut croire une version plus rapide alors qu'il n'en est rien.
					Par exemple, on peut se dire que décomposer un calcul
					ralentit un programme puisqu'il doit gérer des variables
					intermédiaires.
					Ce n'est pas forcément le cas.
					Les compilateurs modernes sont capables
					de nombreuses prouesses pour optimiser le code
					et fournir un résultat aussi rapide
					qu'avec un calcul non décomposé.
				\item
					L'expérience montre que la recherche de rapidité
					mène souvent à des algorithmes moins lisibles.
					Or la lisibilité doit être privilégiée à la rapidité
					car sinon il sera impossible de corriger et/ou
					de faire évoluer l'algorithme.
			\end{itemize}
		
			Ce critère est un cas particulier de l'\emph{efficience}
			qui traite de la gestion économe des ressources.
			Nous reparlerons de rapidité
			dans le chapitre consacré à la \emph{complexité}
			des algorithmes.
		
		%---------------------	
		\subsection{La taille}
		%---------------------
		
			Nous voyons parfois des étudiants contents d'avoir
			pu écrire un algorithme en moins de lignes.
			Ce critère n'a \textbf{aucune importance} ;
			un algorithme plus court n'est pas nécessairement
			plus rapide ni plus lisible.
		
		%----------------------		
		\subsection{Conclusion}
		%----------------------		
			
			Tout ces critères n'ont pas le même poids.
			Le point le plus important est bien sûr d'écrire
			un algorithme correct mais ne vous arrêtez pas là !
			Demandez-vous s'il n'est pas possible de le re-travailler
			pour améliorer sa lisibilité%
			\footnote{%
				On appelle \emph{refactorisation}
				l'opération qui consiste à modifier
				un algorithme ou un code
				sans changer ce qu'il fait
				dans le but,
				notamment, de le rendre plus lisible.
			}.
		
	%======================
	\section{Améliorer la lisibilité d'un algorithme}\label{lisibilite}\index{lisibilite}
	%======================
		
		On vient de le voir, la lisibilité est une qualité essentielle
		que doivent avoir nos algorithmes.
		Qu'est ce qui permet d'améliorer la lisibilité d'un algorithme ?
		
		\begin{enumerate}
		\item
			Il y a d'abord la \textbf{mise en page} qui aide le lecteur
			à avoir une meilleure vue d'ensemble de l'algorithme,
			à en repérer rapidement la structure générale.
			Ainsi, dans ce syllabus :
			\begin{itemize}
			\item 
				Les mots imposés 
				(on parle de \emph{mots-clés}\index{mots-clés})
				sont mis en évidence (en gras%
				\footnote{%
					Difficile de mettre en gras avec un bic.
					Dans une version écrite vous pouvez :
					souligner le mot, le mettre en couleur ou
					l'écrire en majuscule.%
				}).
			\item
				Les instructions à l'intérieur de l'algorithme sont 
				\emph{indentées}\index{indentation}
				(décalées vers la droite).
				On indentera également les instructions
				à l'intérieur des choix et des boucles.
			\item
				Des lignes verticales relient le début et la fin
				de quelque chose. 
				Ici, un algorithme mais on pourra l'utiliser
				également pour les choix et les boucles. 
			\end{itemize}
			
			\textbf{Exemples à ne pas suivre.}
			\\
			\begin{wrong}
				\begin{LDA}
					\Entete{duréeTrajet}{\Par{vitesseMS, distanceKM}{réel}}{réel}
					\Decl{distanceM}{réel}
					\Let distanceM \Gets 1000 * distanceKM
					\Return distanceM / vitesseMS
					\Stmt \K{Fin algorithme}
				\end{LDA}
			\end{wrong}
			
			\begin{wrong}
				\begin{LDA}
					\Algo{duréeTrajet}{\Par{vitesseMS, distanceKM}{réel}}{réel}
						\Decl{distanceM}{réel}
						\Let \quad distanceM \Gets 1000 * distanceKM
						\qquad \K{return} distanceM / vitesseMS
					\EndAlgo
				\end{LDA}
			\end{wrong}
	
			Il faudra préférer
			\begin{LDA}
			\Algo{duréeTrajet}{\Par{vitesseMS, distanceKM}{réel}}{réel}
				\Decl{distanceM}{réel}
				\Let distanceM \Gets 1000 * distanceKM
				\Return distanceM / vitesseMS
			\EndAlgo
			\end{LDA}
			\medskip
		
		\item
			Il y a, ensuite, l'écriture des instructions elles-mêmes.
			Ainsi :
			\begin{itemize}
			\item
				Il faut choisir soigneusement les noms 
				(d'algorithmes, de paramètres, de variables\dots)
			\item
				Il faut décomposer (ou au contraire fusionner)
				des calculs pour arriver au résultat qu'on jugera
				le plus lisible.
			\item 
				On peut introduire des commentaires et/ou
				des constantes. 
				Deux concepts que nous allons développer maintenant.
			\end{itemize}
			
		\end{enumerate}
				
		%------------------------------------------------
		\subsection{Les commentaires}\index{commentaires}
		%------------------------------------------------
	
			\marginicon{definition}
			\textbf{Commenter} un algorithme
			signifie lui ajouter du texte explicatif
			destiné au \textbf{lecteur} pour l'aider à mieux
			comprendre le fonctionnement de l'algorithme.
			Un commentaire n'est pas utilisé par celui qui exécute
			l'algorithme; il ne modifie pas ce que l'algorithme fait.
			
			Habituellement, on distingue deux sortes de commentaires :
			\begin{itemize}
			\item
				Ceux placés \textbf{au-dessus} de l'algorithme
				qui expliquent \textbf{ce que fait} l'algorithme
				et dans quelles \textbf{conditions} il fonctionne
				(les contraintes sur les paramètres).
			\item
				Ceux placés \textbf{dans} l'algorithme
				qui expliquent \textbf{comment} il le fait.
			\end{itemize}
			
			Commenter correctement un programme
			est une tâche qui n'est pas évidente et qu'il faut travailler.
			Il faut arriver à apporter au lecteur
			une information \textbf{utile}
			qui n'apparait pas directement dans le code.
			Par exemple, il est contre-productif de répéter
			ce que l'instruction dit déjà.
			Voici quelques mauvais commentaires
			
			\begin{LDA}
				\LComment{Exemples de mauvais commentaires}
				\Decl{longueur}{réel} \RComment{La longueur est un réel}
				\Let somme \Gets 0 \RComment{On initialise la somme à 0} 
			\end{LDA}
			
			Notez qu’un excès de commentaires peut être le révélateur
			des problèmes de lisibilité du code lui-même.
			Par exemple, un choix judicieux de noms de variables 
			peut s’avérer bien plus efficace que des commentaires. 
			Ainsi, l’instruction
	
			\begin{LDA}
			\Let nouveauCapital \Gets ancienCapital * (1 + taux / 100)
			\end{LDA}
	
			dépourvue de commentaires est bien préférable aux lignes suivantes~:
	
			\begin{LDA}
			\Let c1 \Gets c0 * (1 + t / 100) \RComment calcul du nouveau capital
			\Empty \RComment c1 est le nouveau capital, c0 est l’ancien capital, t est le taux
			\end{LDA}
			
			\bigskip
			Pour résumer :
			\begin{quote}
				\bfseries
				N'hésitez pas à mettre des commentaires
				au-dessus du programme pour expliquer ce qu'il fait
				et re-travaillez votre algorithme pour que tout
				commentaire à l'intérieur de l'algorithme
				devienne superflu.
			\end{quote}

			\paragraph{Exemple.}
			Voici comment on pourrait commenter un de nos algorithmes.
			\begin{LDA}
				\LComment{Calcule la surface d'un rectangle dont on donne la largeur et la longueur.}
				\LComment{On considère que les données ne sont pas négatives.}
				\Algo{surfaceRectangle}{\Par{longueur, largeur}{réel}}{réel}
					\Return longueur * largeur
				\EndAlgo
			\end{LDA}
			
			\begin{Exercice}{Commenter la durée du trajet}
				Commentez l'algorithme qui calcule la durée d'un trajet
				(exercice \vref{algo:durée}).
			\end{Exercice}
			
		%--------------------------------------------
		\subsection{Constantes}\index{constantes}
		%--------------------------------------------
	
			Une \textbf{constante} est une information pour laquelle nom, type et
			valeur sont figés. La liste des constantes utilisées dans un algorithme
			apparaitra dans la section déclaration des variables%
			\footnote{%
				Ou en dehors des algorithmes s'il s'agit d'une
				constante universelle partagée par plusieurs algorithmes.%
			} 
			sous la forme suivante%
			\footnote{%
				L'usage est d'utiliser des noms en majuscule.%
			}~:
	
			\begin{LDA}
				\Const{PI}{3,1415}
				\Const{SEUIL\_RÉUSSITE}{12}
				\Const{ESI}{{\textquotedbl}École Supérieure d’Informatique{\textquotedbl}}
			\end{LDA}
	
			Il est inutile de spécifier leur type, celui-ci
			étant défini implicitement par la valeur de la constante.	
			L'utilisation de constantes dans vos algorithmes présente
			les avantages suivants :
			\begin{itemize}
			\item
				Une meilleure lisibilité du code,
				pour autant que vous lui trouviez un nom explicite.
			\item
				Une plus grande facilité pour modifier le code
				si la constante vient à changer 
				(modification légale du seuil de réussite par exemple).
			\end{itemize}
			
			\begin{Exercice}{Utiliser une constante}
				Trouvez un algorithme que vous avez écrit
				où l'utilisation de constante
				pourrait améliorer la lisibilité de votre solution.
			\end{Exercice}
			
	%=====================================
	\section{Interagir avec l'utilisateur}
	%=====================================
	
		Reprenons l'algorithme \lda{surfaceRectangle}
		qui nous a souvent servi d'exemple.
		Il permet de calculer la surface d'un rectangle
		dont on connait la longueur et la largeur.
		Mais d'où viennent ces données ?
		Et que faire du résultat ?
		
		Tout d'abord, un algorithme peut utiliser 
		(on dit \textbf{appeler}\index{appel}) un autre algorithme%
		\footnote{%
			Cet autre algorithme doit exister \emph{quelque part} :
			sur la même page, une autre page, un autre document,
			peu importe.
			Quand on codera cet algorithme,
			les contraintes seront plus fortes
			car il faudra que l'ordinateur
			trouve cet autre bout de code
			pour pouvoir l'exécuter.
		}.
		Pour ce faire, il doit spécifier les valeurs des paramètres ;
		il peut alors utiliser le résultat.
		L'appel s'écrit ainsi :
		
		\begin{LDA}
			\Let surface \Gets surfaceRectangle(122,3.78) \RComment{On appelle l'algorithme surfaceRectangle}
		\end{LDA}
		
		L'appel d'un algorithme est considéré comme une expression,
		un calcul qui, comme toute expression,
		possède une valeur (la valeur retournée)
		et peut intervenir dans un calcul plus grand, 
		être assignée à une variable\dots
	
		%-----------------------------------------
		\subsection{Afficher un résultat}\index{afficher}
		%-----------------------------------------
		
			Si on veut écrire un programme concret (en Java par exemple)
			qui permet de calculer des surfaces de rectangles,
			il faudra bien que ce programme communique le résultat
			à l'utilisateur du programme.
			On va l'indiquer avec la commande \lda{\K{afficher}}. 
			Ce qui donne :
			
			\begin{LDA}
				\Let surface \Gets surfaceRectangle(122,3.78)
				\Write{surface}
			\end{LDA}
	
			ou, plus simplement :
		
			\begin{LDA}
				\Write{surfaceRectangle(122,3.78)}
			\end{LDA}
	
			L'instruction \lda{\K{afficher}} signifie 
			que l'algorithme doit, à cet endroit de l'algorithme
			communiquer une information à l'utilisateur.
			La façon dont il va communiquer cette information 
			(à l'écran dans une application texte, 
			via une application graphique,
			sur un cadran de calculatrice ou de montre,
			sur une feuille de papier imprimée,
			via un synthétiseur vocal\dots)
			ne nous intéresse pas ici%
			\footnote{%
				Ce sera bien sûr une question importante
				quand il s'agira de traduire l'algorithme en un programme.%
			}.		
	
		%-----------------------------------------
		\subsection{Demander des valeurs}\index{demander}
		%-----------------------------------------
	
			Le bout d'algorithme qu'on vient d'écrire
			n'est pas encore très utile puisqu'il calcule
			toujours la surface du même rectangle.
			Il serait intéressant de demander à l'utilisateur
			ce que valent la longueur et la largeur.
			C'est le but de la commande \lda{\K{demander}}. 
	
			\begin{LDA}
				\Read{longueur}
				\Read{largeur}
				\Write{surfaceRectangle(longueur, largeur)}
			\end{LDA}
	
			L'instruction \lda{\K{demander}}
			signifie que l'utilisateur va,
			à cet endroit de l'algorithme,
			être sollicité pour donner une valeur 
			qui sera affectée à une variable.
			À nouveau, la façon dont il va indiquer cette valeur
			(au clavier dans une application texte, 
			via un champ de saisie ou une liste déroulante 
			dans une application graphique,
			via une interface tactile,
			via des boutons physiques,
			via la reconnaissance vocale\dots)
			ne nous intéresse pas ici.
	
			On peut combiner les demandes et écrire :
			
			\begin{LDA}
				\Read{longueur, largeur}
				\Write{surfaceRectangle(longueur, largeur)}
			\end{LDA}
		
		%-----------------------------------------
		\subsection{Algorithme sans paramètre}
		%-----------------------------------------
			
			Les paramètres d'un algorithme sont destinés
			aux autres algorithmes qui vont l'utiliser.
			Ils ne sont pas présents lorsque les données
			sont précisées par l'utilisateur.
			Idem pour la valeur de retour.
			Au final, on pourrait écrire :
	
			\begin{LDA}
				\Algo{TestSurface}{}{}
					\Decl{longueur, largeur}{réel}
					\Read{longueur, largeur}
					\Write{surfaceRectangle(longueur, largeur)}
				\EndAlgo
			\end{LDA}
		
			Cet algorithme n'a ni paramètre ni valeur de retour
			mais il fait appel (utilise) un autre algorithme.

		%-----------------------------------------
		\subsection{Préférer les paramètres}
		%-----------------------------------------
			
			Un algorithme avec paramètres 
			est toujours plus intéressant
			qu'un algorithme qui demande les données
			et affiche le résultat
			car il peut être utilisé (appelé) dans un autre algorithme
			pour résoudre une partie du problème.
			
